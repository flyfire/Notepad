Android流量监控模块学习
====================
+ ``SparseArrays`` map integers to Objects.  Unlike a normal array of Objects,there can be gaps in the indices.  It is intended to be more **memory efficient than** using a ``HashMap`` to map Integers to Objects,both because it avoids auto-boxing keys and its data structure doesn't rely on an extra entry object for each mapping.
+ ``Parcel`` Container for a message (data and object references) that can be sent through an ``IBinder``. A Parcel can contain both flattened data that will be unflattened on the other side of the IPC (using the various methods here for writing specific types, or the general Parcelable interface), and references to live IBinder objects that will result in the other side receiving a proxy IBinder connected with the original IBinder in the Parcel.Parcel is not a general-purpose serialization mechanism. This class (and the corresponding Parcelable API for placing arbitrary objects into a Parcel) is designed as a high-performance IPC transport. As such, it is not appropriate to place any Parcel data in to persistent storage: changes in the underlying implementation of any of the data in the Parcel can render older data unreadable.Parcel被设计用来做高性能IPC，不适合做序列化。
+ ``ConnectivityManager`` Class that answers queries about the state of network connectivity.查询网络连接状态 It also notifies applications when network connectivity changes. Get an instance of this class by calling ``Context.getSystemService(Context.CONNECTIVITY_SERVICE)``.The primary responsibilities of this class are to:
	+ Monitor network connections (Wi-Fi, GPRS, UMTS, etc.)
	+ Send broadcast intents when network connectivity changes
	+ Attempt to "fail over" to another network when connectivity to a network is lost
	+ Provide an API that allows applications to query the coarse-grained or fine-grained state of the available networks
+ ``NetworkPolicyManager`` Manager for creating and modifying network policy rules.
+ ``NetworkStatsService`` Collect and persist detailed network statistics, and provide this data to other system services. ``NetworkStatsSettings``Settings that can be changed externally.
+ ``HandlerThread`` Handy class for starting a new thread that has a looper. The looper can then be used to create handler classes. Note that ``start()`` must still be called.
+ ``RemoteCallbackList`` Takes care of the grunt work of maintaining a list of remote interfaces, typically for the use of performing callbacks from a Service to its clients. ``RemoteCallbackList``主要用来处理service对client的回调处理。In particular, this:
	+ Keeps track of a set of registered ``IInterface`` callbacks, taking care to identify them through their underlying unique ``IBinder`` (by calling ``IInterface.asBinder()``.
	+ Attaches a ``IBinder.DeathRecipient`` to each registered interface, so that it can be cleaned out of the list if its process goes away.
	+ Performs locking of the underlying list of interfaces to deal with multithreaded incoming calls, and a thread-safe way to iterate over a snapshot of the list without holding its lock.
To use this class, simply create a single instance along with your service, and call its ``register(E)`` and ``unregister(E)`` methods as client register and unregister with your service. To call back on to the registered clients, use ``beginBroadcast()``, ``getBroadcastItem(int)``, and ``finishBroadcast()``.If a registered callback's process goes away, this class will take care of automatically removing it from the list. If you want to do additional work in this situation, you can create a subclass that implements the ``onCallbackDied(E)`` method.要使用这个类，创建一个和你的服务相连的实例，client调用``register(E)``和``unregister(E)``来register和unregister service。
+ ``NetworkStats`` Creates ``NetworkStats`` instances by parsing various ``/proc/`` files as needed. Collection of active network statistics. Can contain summary details across all interfaces, or details with per-UID granularity. Internally stores data as a large table, closely matching ``/proc/`` data format. This structure optimizes for rapid in-memory comparison, but consider using ``NetworkStatsHistory`` when persisting.``NetworkStats``是活动网络数据收集的集合，包含所有活跃的网络接口的统计信息，或者每个UID的细节。在内存中使用一个很大的表作为存储，格式和``/proc``中数据存储格式很相似。``NetworkStats``存储结构为内存内的比较进行了优化，如果需要持久化的话，考虑使用``NetworkStatsHistory``吧。
+ ``Context.enforceCallingOrSelfPermission(String permission, String message)`` If neither you nor the calling process of an IPC you are handling has been granted a particular permission, throw a ``SecurityException``.被授予特殊权限的时候抛出``SecurityException``异常。
+ ``NativeDaemonConnector`` Generic connector class for interfacing with a native daemon which uses the ``libsysutils`` FrameworkListener protocol.通用的用来和使用了``libsysutils`` FrameworkListener协议的本地守护进程进行交互的connector class。
+ ``PendingIntent`` A description of an ``Intent`` and target action to perform with it. Instances of this class are created with ``getActivity(Context, int, Intent, int)``, ``getActivities(Context, int, Intent[], int)``, ``getBroadcast(Context, int, Intent, int)``, and ``getService(Context, int, Intent, int)``; the returned object can be handed to other applications so that they can perform the action you described on your behalf at a later time.返回的对象可以交给其他应用程序，这样其他应用程序可以以你的身份之后执行在``PendingIntent``中描述的操作。By giving a ``PendingIntent`` to another application, you are granting it the right to perform the operation you have specified as if the other application was yourself (with the same permissions and identity). As such, you should be careful about how you build the ``PendingIntent``: almost always, for example, the base Intent you supply should have the component name explicitly set to one of your own components, to ensure it is ultimately sent there and nowhere else.将``PendingIntent``传递给其他对象意味着给其他应用程序授权，因此应该在构建``PendingIntent``时加倍小心，应该显示设置要传递的component name。A ``PendingIntent`` itself is simply a reference to a token maintained by the system describing the original data used to retrieve it. This means that, even if its owning application's process is killed, the ``PendingIntent`` itself will remain usable from other processes that have been given it. If the creating application later re-retrieves the same kind of ``PendingIntent`` (same operation, same Intent action, data, categories, and components, and same flags), it will receive a ``PendingIntent`` representing the same token if that is still valid, and can thus call cancel() to remove it.``PendingIntent``是一个引用。Because of this behavior, it is important to know when two Intents are considered to be the same for purposes of retrieving a PendingIntent. A common mistake people make is to create multiple PendingIntent objects with Intents that only vary in their "extra" contents, expecting to get a different PendingIntent each time. This does not happen. The parts of the Intent that are used for matching are the same ones defined by Intent.filterEquals. If you use two Intent objects that are equivalent as per Intent.filterEquals, then you will get the same PendingIntent for both of them.
+ ``IntentFilter`` Structured description of ``Intent`` values to be matched. An ``IntentFilter`` can match against **actions**, **categories**, and **data (either via its type, scheme, and/or path)** in an Intent. It also includes a "priority" value which is used to order multiple matching filters.``IntentFilter`` objects are often created in XML as part of a package's ``AndroidManifest.xml`` file, using ``intent-filter`` tags.There are three ``Intent`` characteristics you can filter on: the action, data, and categories. For each of these characteristics you can provide multiple possible matching values (via ``addAction(String)``, ``addDataType(String)``, ``addDataScheme(String)``, ``addDataSchemeSpecificPart(String, int)``, ``addDataAuthority(String, String)``, ``addDataPath(String, int)``, and ``addCategory(String)``, respectively). For actions, the field will not be tested if no values have been given (treating it as a wildcard); if no data characteristics are specified, however, then the filter will only match intents that contain no data.
+ ``DropBoxManager`` Enqueues chunks of data (from various sources -- application crashes, kernel log records, etc.). The queue is size bounded and will drop old data if the enqueued data exceeds the maximum size. You can think of this as a persistent, system-wide, blob-oriented "logcat".You can obtain an instance of this class by calling ``getSystemService(String)`` with ``DROPBOX_SERVICE``.``DropBoxManager`` entries are not sent anywhere directly, but other system services and debugging tools may scan and upload entries for processing.``DropBoxManager``将不同来源的数据入列。队列有大小，超出队列大小时，将会把旧数据丢弃，可以把``DropBoxManager``当做一个持久化的，系统范围的，二进制的``logcat``。可以从服务中得到它。
+ ``NetworkStatsRecorder`` Logic to record deltas between periodic ``NetworkStats`` snapshots into ``NetworkStatsHistory`` that belong to ``networkStatsCollection``.Keeps pending changes in memory until they pass a specific threshold, in  bytes. Uses ``FileRotator`` for persistence logic.Not inherently thread safe.
+ ``NetworkStatsCollection`` Collection of ``NetworkStatsHistory``, stored based on combined key of ``NetworkIdentitySet``, UID, set, and tag. Knows how to persist itself.
+ ``AtomicFile`` Helper class for performing atomic operations on a file by creating a backup file until a write has successfully completed. If you need this on older versions of the platform you can use ``AtomicFile`` in the v4 support library.Atomic file guarantees file integrity by ensuring that a file has been completely written and sync'd to disk before removing its backup. As long as the backup file exists, the original file is considered to be invalid (left over from a previous attempt to write the file).通过创建一个文件的备份来保证在文件上的操作是原子性的，保证文件被写入并同步到了磁盘，这些操作没有完成不会删除备份文件，如果备份文件存在，原来的文件就是不合法的，因为也许上一次尝试写入文件没有完成就离开了。Atomic file does not confer any file locking semantics. Do not use this class when the file may be accessed or modified concurrently by multiple threads or processes. The caller is responsible for ensuring appropriate mutual exclusion invariants whenever it accesses the file.``AtomicFile``不提供锁机制，当这个文件可能被并发访问或修改时不要使用``AtomicFile``。
+ Android系统原生自带的``style.xml``在目录``framework/base/core/res/res/values/styles.xml``
+ ``NetworkTemplate`` Template definition used to generically match ``NetworkIdentity``,usually when collecting statistics.``NetworkTemplate``主要用来收集统计信息。
+ ``Loader`` An abstract class that performs asynchronous loading of data. While Loaders are active they should monitor the source of their data and deliver new results when the contents change.
+ ``ContentResolver`` ``public final void registerContentObserver (Uri uri, boolean notifyForDescendents, ContentObserver observer)`` Register an observer class that gets callbacks when data identified by a given content URI changes.注册一个observer类，当给定的URI所指向的内容发生变化时，用来回调。
====================================================================
# 流量监控主要用到的类
+ ``INetworkStatsSession``:Return network layer usage summary(historical network layer stats) for traffic that matches template.Return network layer usage summary per UID for traffic that matches template.Return historical network layer stats for specific UID traffic that matches template.
+ ``NetworkTemplate``:Template definition used to generically match ``NetworkIdentity``,usually when collecting statistics.
+ ``NetworkStatsHistory``:Collection of historical network statistics, recorded into equally-sized "buckets" in time. Internally it stores data in ``long`` series for more efficient persistence.Each bucket is defined by a ``bucketStart`` timestamp, and lasts for ``bucketDuration``. Internally assumes that ``bucketStart`` is sorted at all times.
+ ``NetworkPolicyEditor``:Utility class to modify list of ``NetworkPolicy``. Specifically knows about which policies can coexist. This editor offers thread safety when talking with ``NetworkPolicyManager``.
+ ``NetworkPolicy``:Policy for networks matching a ``NetworkTemplate``, including usage cycle and limits to be enforced.
+ ``NetworkStatsService``:Collect and persist detailed network statistics, and provide this data to other system services.
+ ``android.net.TrafficStats.UID_REMOVED``,``android.net.TrafficStats.UID_TETHERING``.
+ ``NetworkStats``:Collection of active network statistics. Can contain summary details across all interfaces, or details with per-UID granularity. Internally stores data as a large table, closely matching ``/proc/`` data format. This structure optimizes for rapid in-memory comparison, but consider using ``NetworkStatsHistory`` when persisting.所有活动网络分析的收集，包括了所有网络接口的总结细节，也可以从单个UID的粒度上来分析。在内部将这些分析数据作为一个大表存储，格式和``/proc``中的数据格式很接近，这种格式特地为内存内的比较进行了优化，持久化存储的时候可以考虑使用``NetworkStatsHistory``。前台数据，后台数据

=================================
+ [NetworkStats](https://github.com/android/platform_frameworks_base/blob/master/core/java/android/net/NetworkStats.java)
+ [NetworkStatsCollection](https://github.com/android/platform_frameworks_base/blob/master/services/java/com/android/server/net/NetworkStatsCollection.java)
+ [NetworkTemplate](https://android.googlesource.com/platform/frameworks/base.git/+/android-4.3_r3/core/java/android/net/NetworkTemplate.java)
public static NetworkTemplate buildTemplateMobile4g(String subscriberId) {
    return new NetworkTemplate(MATCH_MOBILE_4G, subscriberId, null);
}
+ NetworkStatsFactory:Creates ``NetworkStats`` instances by parsing various ``/proc/`` files as needed.
