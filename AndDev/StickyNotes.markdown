+ Activity ``getIntent()`` Return the intent that started this activity.
+ PackageManager ``queryIntentActivities(Intent intent, int flags)`` Retrieve all activities that can be performed for the given intent. 取得所有可以对给定intent响应的activity。
+ ResolveInfo ``loadLabel(PackageManager pm)`` Retrieve the current textual label associated with this resolution.
+ ``ApplicationInfo`` Information you can retrieve about a particular application. This corresponds to information collected from the ``AndroidManifest.xml's <application>`` tag.``ApplicationInfo`` 所有可以从特定应用中取得的信息，和从``AndroidManifest.xml``文件``<application>``节点中搜集来的信息一一对应。
+ ``PackageInfo`` Overall information about the contents of a package. This corresponds to all of the information collected from ``AndroidManifest.xml``.关于package的所有信息，和在``AndroidManifest.xml``中搜集来的信息对应。
+ ``android:sharedUserLabel`` A user-readable label for the shared user ID. The label must be set as a reference to a string resource; it cannot be a raw string.This attribute was introduced in API Level 3. It is meaningful only if the sharedUserId attribute is also set. ``AndroidManifest.xml``中``<manifest>`` tag中的``android:sharedUserLabel``是一个对用户可读的表示``sharedUserId``的字符串，必须设置为一个string资源的引用，不能是raw string。只有在``android:sharedUserId``也被设置的时候才有意义。
+ Prior to Android 2.0, devices have seen a lot of services hanging around and claiming resources even though there was no work to be done, meaning Android brought the services back into memory even though there were no messages in the queue. This would have happened when ``stopService`` was not invoked either because of an exception or because the process was taken out between ``onStartCommandand`` and ``stopService``. Android2.0之前，即使没有工作要做，系统也会在内存中挂起许多服务占用资源，这会在``stopService``由于异常或者进程在``onStartCommand``和``stopService``之间被清除而未被调用时发生。Android 2.0 introduced a solution so that we can indicate to the system, if there are no pending intents, that it shouldn’t bother restarting the service. This is OK because whoever started the service to do the work will call it again, such as the alarm manager.This is done by returning the nonsticky flag (``Service.START_NOT_STICKY``) from
``onStartCommand``.Android 2.0引入了一种新机制，可以通知系统如果没有 pending intents，service不用被重新启动。在``onStartCommand``方法中返回``Service.START_NOT_STICKY``可以达到此目的。However, nonsticky is not really that nonsticky. Remember, even if we mark the service as nonsticky, if there are pending intents, Android will bring the service back to life. This setting applies only when there are no pending intents.

+ The sticky flag (``Service.START_STICKY``) means that Android should restart the service even if there are no pending intents. When the service is restarted, call ``onCreate`` and ``onStartCommand`` with a null intent. This will give the service an opportunity, if need be, to call ``stopSelf`` if that is appropriate. The implication is that a service that is sticky needs to deal with null intents on restarts.``Service.STAT_STICKY``标志指示系统即使在没有pending intents时也应该重启service，service重启时，传递null intent以调用``onCreate``和``onStartCommand``。